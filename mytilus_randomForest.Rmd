---
title: "Prädiktives Mytilus Modell aus Random Forests"
author: "Charlotte Schramm und Carsten Lemmen"
copyright: "Helmholtz-Zentrum Geesthacht, 2018"
license: "This report is released  under the CC-by-SA 4.0 license."
date: "Aug 9, 2018"
output: html_document
---

> Dieses Dokument ist in **Markdown** verfasst, siehe http://markdown.de für eine kurze Einführung.  Dieses Verzeichnis steht unter https://git-scm.com Versionskontrolle. Es ist online gehostet unter https://github.com/platipodium/random-forest-benthos. Bitte den `Knit`-Button in RStudio drücken, um eine nett formatiertes Dokument zu erhalten.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Mytilus (Miesmuschel) Punktdaten

Der Mytilus-Datensatz enthält ungefähr 30000 Positionen von positivem Vorkommen der Miesmuschel.  Diese werden aus einer `CSV` ("character-separated-value")-Datei gelesen. Offenbar kann man in diesem Fall nicht die Funktion read.table anwenden, da dadurch etwa 2800 Zeilen nicht eingelesen werden. Stattdessen kann die Funktion read.csv angewendet werden.

```{r}
#mytilus <- read.table("Mytilus_SNS4_AP.csv",header=T,sep=";",dec=".")
mytilus <- read.csv("Mytilus_SNS4_AP.csv",sep=";")
summary(mytilus)
```

Die Daten müssen noch gereinigt werden, d.h.  auf fehlerhafte Koordinaten, Duplikate und nicht-Mytilus Angaben überprüft werden. Die Mittelmeer-Miesmuschel soll ebenfalls ausgeschlossen werden. Außerdem behalten wir nur die Presence-Werte. 

```{r}
mytilus.valid = subset(mytilus, 
  !is.na(mytilus$Lat) & 
  !is.na(mytilus$Lon) &
  grepl("Mytilus", mytilus$Species) &
  !grepl("Mytilus galloprovincialis",mytilus$Species)&
  !grepl("Mytilus edulis galloprovincialis",mytilus$Species)&
  grepl("Presence", mytilus$PA))
mytilus.duplicates = duplicated(mytilus.valid[, c("Lat","Lon")]) 
mytilus.deduplicated <- subset(cbind(mytilus.valid,mytilus.duplicates), mytilus.duplicates==FALSE)
mytilus.cleaned=mytilus.deduplicated[c("Lon","Lat","PA","Source")]
summary(mytilus.cleaned)
```

Wir benutzen den Dataframe jetzt als spatial data und reichern es mit
Information zu Koordinaten und Referenzsystem aus dem `sp`-Paket an:

```{r}
library(sp)
coordinates(mytilus.cleaned) <- ~Lon + Lat
proj4string(mytilus.cleaned)<-CRS("+init=epsg:4326")
spplot(mytilus.cleaned,"PA",cex=0.1,col.regions=c("red","black"),scales=list(draw=TRUE),main=list(label="Point data of Mytilus",cex=1))
```

# Korngröße (Teil 1)

Die Sedimentdaten sind in zwei Versionen vorhanden, einmal in der Datei `
Predictor.rda` und in einer weiteren Datei `interpolated_d50_NorthSea_1nm.txt`. Hier der Versuch mit der ersten (später besser die zweite nehmen, s.u.).  Die Rohdaten sind Mittlere Korngröße ("median grain size", mgs), und werden in der Krumbein-Phi-Skala dargestellt, d.h. den negativen binären Logarithmus der auf 1 mm normierten Korngröße. 

```{r}
load("Predictor.rda")
library(RColorBrewer)
library(sp)
spplot(Predictor,"mgs",formula=-log2(mgs/1000)~s1+s2,
      col.regions = brewer.pal(11, "Spectral"),
      at=c(-5,-4,-3,-2,-1,0,1,2,3,4,5),
      pretty=TRUE,
      main=list(label="Median grain size (mgs)",cex=1),
      scales=list(draw=TRUE)
      )
library(grid)
grid.text("-log2(mgs/1mm)",x=unit(0.99,"npc"),y=unit(0.50,"npc"),rot=-90,check.overlap = TRUE)

Predictor$phi <- -log2(Predictor$mgs/1000)
```

Die entscheinden Schritte, um die Umweltdaten mit den Muscheldaten zusammenzubringen, benötigen das Paket `crecs` von `github`.  Dieses muss mithilfe der `devtools` installiert werden.

```{r}
library(devtools)
#devtools::install_github("janhoo/crecs")
library(crecs)
```
Aus diesem Paket kann der Befehl `get.environ` zu gegebenen Punktdaten (`points`) einen Vektor mit Daten aus der Umgebung (`env`) erzeugen. Die Daten werden auf den Bereich der Korngröße zugeschnitten und nur die Spalten PA, mgs und depth werden behalten

```{r}
myt.env<-get.environ(points=mytilus.cleaned,env=stack(Predictor))
#clip the points to SNS
myt.env2<-myt.env[!is.na(myt.env$phi),]
myt.env2 <- myt.env2[,c("PA","depth","mgs","phi")]
summary(myt.env2)
```

Man kann nun mit spplot Korngröße und Vorkommen von Mytilus gegenüberstellen.
```{r}
library(rworldxtra)
data(countriesHigh)
PA2_plot <- spplot(myt.env2,"PA",cex=0.5,col.regions=c("black","red"),
                   main=list(label="Point data Mytilus",cex=1),
                   ylim=c(51.062591,55.971701),xlim=c(-2.250885,8.714282),
                   sp.layout=list("sp.polygons",countriesHigh,fill="grey"))
val_plot <- spplot(myt.env2,"phi",cex=0.5,
                   main=list(label="Point data median grain size",cex=1),
                   ylim=c(51.062591,55.971701),xlim=c(-2.250885,8.714282),
                   sp.layout=list("sp.polygons",countriesHigh,fill="grey"))
library(gridExtra)
grid.arrange(val_plot,PA2_plot,ncol=2)
```

Bisher haben wir nur Presence-Daten für Mytilus. Die Punkte, an denen Mytilus nicht vorkommt, müssen erst noch zufällig generiert werden. Die Funktion randomPoints ist genau für solche Fälle gedacht, sie generiert pseudo-absence Daten. Die Anzahl der generierten Punkte soll denen der Presence-Punkte entsprechen. Es sind 1259 Punkte.

```{r}
set.seed(1)
library(dismo)
random.absence.forPredictor <- randomPoints(Predictor,n=1259,mytilus.cleaned)
  #Umwandlung in einen Dataframe und Zuweisung der Koordinaten und eines 
    #Koordinaten-Refererenz Systems --> class=SpatialPoints
random.absence.forPredictor <- as.data.frame(random.absence.forPredictor)
coordinates(random.absence.forPredictor) <- ~ x+y
proj4string(random.absence.forPredictor) <- CRS("+init=epsg:4326")
  #Zusammenbringen der Absence-Punkte mit dem Korngrößen-Datensatz
myt.absence <- get.environ(random.absence.forPredictor,stack(Predictor))

#Kombinieren von Presence und Absence Punkten und schreiben als 1 für presence und 0 für absence
myt.env2$PA2 <- 1
myt.absence$PA2 <- 0
library(maptools)
sedPA.bind <- spRbind(myt.env2[,2:ncol(myt.env2)],myt.absence[,c("depth","mgs","PA2","phi")])
sedPA.bind$PA2 <- as.factor(sedPA.bind$PA2)
spplot(sedPA.bind,"PA2",cex=0.5,col.regions=c("black","red"),
       main=list("Presence and random absence data of Mytilus",cex=1),
       scales=list(draw=TRUE),
       ylim=c(51.062591,55.971701),xlim=c(-2.250885,8.714282),
       sp.layout=list("sp.polygons",countriesHigh,fill="grey")
       )
```

Nun kann das Random Forest Modell angewendet werden. Dazu gibt es ein extra Paket 'randomForest', das zuerst geladen werden muss.

```{r}
sedPA.bind <- spRbind(myt.env2[,2:ncol(myt.env2)],myt.absence[,c("depth","mgs","PA2","phi")])
sedPA.bind.df <- data.frame(sedPA.bind)
library(randomForest)
rf.p <- randomForest(PA2~phi,data=sedPA.bind.df,ntree=500)
sedPA.bind$Prediction <- rf.p$predicted
library(dismo)
Predictor$prediction1 <- predict(rf.p,Predictor)
spplot(Predictor,"prediction1",main=list("Occurence probability",cex=1),col.regions = brewer.pal(10,"Spectral"),
      at=seq(from=0,to=1,by=0.1),pretty=TRUE, 
      ylim=c(51.062591,55.971701),xlim=c(-2.250885,8.714282),
      sp.layout=list("sp.polygons",countriesHigh,fill="grey"))
grid.text("probability",x=unit(0.98,"npc"),y=unit(0.50,"npc"),rot=-90,check.overlap = TRUE)
```
Wie verändert sich das Bild, wenn wir als zweiten Prädiktor die Tiefe mit in das Random Forest Modell hinein nehmen?
```{r}
rf.p.withdepth <- randomForest(PA2~phi+depth,data=sedPA.bind.df,ntree=500)
sedPA.bind$PredictionWithDepth <- rf.p.withdepth$predicted
library(dismo)
Predictor$predictionWithDepth <- predict(rf.p.withdepth,Predictor)
spplot(Predictor,"predictionWithDepth",main=list("Occurence probability",cex=1),
       col.regions = brewer.pal(11, "Spectral"),
       at=seq(from=0,to=1,by=0.1),
       pretty=TRUE,
       ylim=c(51.062591,55.971701),xlim=c(-2.250885,8.714282),
       sp.layout=list("sp.polygons",countriesHigh,fill="grey")
       )
grid.text("probability",x=unit(0.98,"npc"),y=unit(0.50,"npc"),rot=-90,check.overlap = TRUE)
```

# Korngröße (Teil 2)

Die zweiten Sedimentdaten aus `interpolated_d50_NorthSea_1nm.txt` liegen schon als phi-Werte vor.  Diese können ordentlich referenziert werden, denn sie stammen  aus dem [NOAH Habitatatlas](www.noah-project.de).

```{r}
sed <- read.table("interpolated_d50_NorthSea_1nm.txt",header=T,dec=".")
sed <- sed[,1:3]
summary(sed)
sed2 <- sed
coordinates(sed2) <- ~lon + lat
proj4string(sed2)<-CRS("+init=epsg:4326")
spplot(sed2,"val",cex=0.1,col.regions=brewer.pal(5,"OrRd"),
       ylim=c(50.924999,60.99167),xlim=c(-3.882318,11.49699),
       sp.layout=list("sp.polygons",countriesHigh,fill="grey")
       )
```

Die Daten sind klassifizierte Punkdaten, die in ein kontinuierliches Raster umgewandelt werden sollen. Die angegebene Wert für tolerance ist der von R vorgeschlagene Wert. Die Angabe des Wertes ist nötig, da die Daten nicht komplett gegridded sind. 


```{r}
sed.pixel=SpatialPixelsDataFrame(sed2,data=sed,tolerance=0.000100658)
spplot(sed.pixel,"val", cex=0.1,
       ylim=c(50.924999,60.99167),xlim=c(-3.882318,11.49699),
       sp.layout=list("sp.polygons",countriesHigh,fill="grey")
       )
```

Die Mytilus- und die Korngrößen-Daten werden nun zusammengeführt und auf den gemeinsamen Bereich zugeschnitten. Damit reduziert sich die Anzahl der Punkte auf 1396.

```{r}
library(crecs)
myt.env<-get.environ(points=mytilus.cleaned,env=stack(sed.pixel))
myt.env <- myt.env[!is.na(myt.env$val),]
summary(myt.env)
```

Es sollen nun 1396 Hintergrundwerte, an denen die Miesmuschel nicht vorkommt, zufällig generiert werden (random-absence). Dies geschieht mit der Funktion randomPoints, die eine Matrix mit x und y Werten erzeugt. Als letztes Argument sind hier die Presence-Punkte angegeben. Dann werden die Zufallswerte nicht in diesen Zellen generiert.

```{r}
set.seed(1)
library(dismo)
random.absence <- randomPoints(sed.pixel,n=1396,mytilus.cleaned)
```

Die Matrix soll in einen SpatialPoints Datensatz umgewandelt werden und bekommt damit einen räumlichen Bezug. Anschließend werden die Absence-Punktdaten mit den Korngrößen-Daten vereint.

```{r}
random.absence <- as.data.frame(random.absence)
coordinates(random.absence) <- ~ x+y
proj4string(random.absence) <- CRS("+init=epsg:4326")

sed.absence <- get.environ(random.absence,stack(sed.pixel))
```

Die Presence-Punktdaten und die generierten Absence-Punktdaten werden jetzt mit einander verbunden. Es wird eine neue Spalte PA2 angelegt, in der das Vorkommen von Mytilus als 1 und die Abwesenheit von Mytilus als 0 definiert wird.

```{r}
myt.env$PA2 <- 1
sed.absence$PA2 <- 0
library(maptools)
mgsPA.bind <- spRbind(myt.env[,3:ncol(myt.env)],sed.absence)
spplot(mgsPA.bind,"PA2",cex=0.01,col.regions=c("black","red"),
       ylim=c(50.924999,60.99167),xlim=c(-3.882318,11.49699),
       sp.layout=list("sp.polygons",countriesHigh,fill="grey"))
```
Mithilfe des Random Forest Modells sollen Vorhersagen über die Wahrscheinlichkeit gemacht werden, mit der die Miesmuschel bei gegebener mittlerer Korngröße vorkommt. Die mittlere Korngröße ist somit der Prädiktor im Modell, das Vorkommen der Miesmuschel die Response-Variable.

```{r}
mgsPA.bind.df <- data.frame(mgsPA.bind)
library(randomForest)
rf <- randomForest(PA2~val,data=mgsPA.bind.df,ntree=500)
mgsPA.bind$Prediction <- rf$predicted
library(dismo)
sed.pixel$prediction <- predict(rf,sed.pixel)
spplot(sed.pixel,"prediction",
       col.regions=brewer.pal(9,"OrRd"),
       at=seq(from=0,to=1,by=1/9),
       ylim=c(50.924999,60.99167),xlim=c(-3.882318,11.49699),
       sp.layout=list("sp.polygons",countriesHigh,fill="grey")
       )
```

Wie ver?ndert sich das Bild, wenn man als zweiten Pr?diktor die Tiefe mit einbezieht? Wir verwenden den Etopo1 Datensatz, der unter https://maps.ngdc.noaa.gov/viewers/wcs-client/ abbrufbar ist. 
Die Daten werden eingelesen und durch Zuweisung des Referenz-Koordinaten-Systems und der Koordinaten in einen SpatialPointsDataFrame umgewandelt.
```{r}
  #Einlesen der Tiefendaten und Umwandlung in SpatialPointsDataFrame
depth.etopo.df <- read.csv("etopo1_bedrock.xyz",sep="",header=FALSE)
depth.etopo <- depth.etopo.df 
coordinates(depth.etopo) <- ~V1 + V2
proj4string(depth.etopo)<-CRS("+init=epsg:4326")
```

Der Datensatz l?sst sich anschlie?end ohne Weiteres in einen SpatialPixelsDataFrame ?berf?hren
```{r}
  #Umwandlung der Tiefendaten in SpatialPixelsDataFrame
depth.pixel <- SpatialPixelsDataFrame(depth.etopo,depth.etopo.df)
spplot(depth.pixel,"V3",col.regions=colorRampPalette(c("beige","brown","blue")))
```
Mit der 'get.environ' Funktion lassen sich dann die Werte jener Punkte extrahieren f?r die auch Grainsize und PA-Werte vorliegen.
```{r}
mgsDepthPA <- get.environ(mgsPA.bind,stack(depth.pixel))
mgsDepthPA <- mgsDepthPA[!is.na(mgsDepthPA$V3),]

spplot(mgsDepthPA,"V3",cex=0.1,
       sp.layout=list("sp.polygons",countriesHigh,fill="grey")
       )
```


Nun kann man das Random Forest Modell erneut anwenden mit Grainsize und Tiefe als Pr?diktoren.
```{r}
rf.withDepth <- randomForest(PA2~ val+V3,mgsDepthPA)
```

Um jedoch die Vorhersagewerte als SpatialPixelsDataFrame zu erhalten und abbilden zu k?nnen, m?ssen zur Anwendung der Funktion `predict` Korngr??e und Tiefe gemeinsam in einem SpatialPixelsDataFrame vorliegen und als zweites Argument der Funktion 'predict' angegeben werden. Das Kombinieren stellt sich allerdings auch wegen unterschiedlicher cellsize als nicht so einfach heraus. Wir benötigen einen neuen SpatialPixelDataFrame, der Tiefe und Korngröße auf einem einheitlichen Gitter abbildet. Wir versuchen die Tiefeninformation auf das Korngrößengitter zu interpolieren. Danach kann `predict` angewendet werden.
```{r}
library(gstat)
# Uncomment to redo the interpolation, which takes about 1 day to compute
# better to read the produced interpolated data from file
#depth.pixel_on_sed.pixel <- krige(formula=V3~1, locations=depth.pixel,newdata=sed.pixel)
#saveRDS(depth.pixel_on_sed.pixel,file="etopo1_interpolated_to_noah_grain=size_grid.rda")
depth.pixel_on_sed.pixel <- readRDS("etopo1_interpolated_to_noah_grainsize_grid.rda")
spplot(depth.pixel_on_sed.pixel,"var1.pred",
       sp.layout=list("sp.polygons",countriesHigh,fill="grey")
       )
depth.pixel_on_sed.pixel$val <- sed.pixel$val
depth.pixel_on_sed.pixel$V3 <- depth.pixel_on_sed.pixel$var1.pred
depth.pixel_on_sed.pixel$prediction <- predict(rf.withDepth,depth.pixel_on_sed.pixel)
spplot(depth.pixel_on_sed.pixel,"prediction",
       col.regions=brewer.pal(11,"Spectral"),
       at=seq(from=0,to=1,by=0.1),
       sp.layout=list("sp.polygons",countriesHigh,fill="grey")
       )

```


# Vergleich der Ergebnisse der beiden Korngrößen-Datensätze

Um die Ergebnisse der beiden Korngrößen-Datensätze besser vergleichen zu können, werden sie auf den gemeinsamen Kartenausschnitt zugeschnitten. Dazu wird die Funktion 'intersect' aus dem Paket 'raster' verwendet.

```{r}
library(raster)
intersect.part2 <- intersect(sed.pixel,Predictor)
grainsize.part2 <- spplot(intersect.part2,"prediction")
intersect.part1 <- intersect(Predictor,sed.pixel)
grainsize.part1 <- spplot(intersect.part1,"prediction1")
grainsize.part1
grainsize.part2
```
