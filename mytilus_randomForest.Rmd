---
title: "Pr√§diktives Mytilus Modell aus Random Forests"
author: "Charlotte Schramm und Carsten Lemmen"
copyright: "Helmholtz-Zentrum Geesthacht, 2018"
license: "This report is released  under the CC-by-SA 4.0 license."
date: "Aug 9, 2018"
output: html_document
---

> Dieses Dokument ist in **Markdown** verfasst, siehe http://markdown.de f√ºr eine kurze Einf√ºhrung.  Dieses Verzeichnis steht unter https://git-scm.com Versionskontrolle. Es ist online gehostet unter https://github.com/platipodium/random-forest-benthos. Bitte den `Knit`-Button in RStudio dr√ºcken, um eine nett formatiertes Dokument zu erhalten.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Mytilus (Miesmuschel) Punktdaten

Der Mytilus-Datensatz enth√§lt ungef√§hr 30000 Positionen von positivem Vorkommen der Miesmuschel.  Diese werden aus einer `CSV` ("character-separated-value")-Datei gelesen. Offenbar kann man in diesem Fall nicht die Funktion read.table anwenden, da dadurch etwa 2800 Zeilen nicht eingelesen werden. Stattdessen kann die Funktion read.csv angewendet werden.

```{r}
#mytilus <- read.table("Mytilus_SNS4_AP.csv",header=T,sep=";",dec=".")
mytilus <- read.csv("Mytilus_SNS4_AP.csv",sep=";")
summary(mytilus)
```

Die Daten m√ºssen noch gereinigt werden, d.h.  auf fehlerhafte Koordinaten, Duplikate und nicht-Mytilus Angaben √ºberpr√ºft werden. Die Mittelmeer-Miesmuschel soll ebenfalls ausgeschlossen werden. Au√üerdem behalten wir nur die Presence-Werte. 

```{r}
mytilus.valid = subset(mytilus, 
  !is.na(mytilus$Lat) & 
  !is.na(mytilus$Lon) &
  grepl("Mytilus", mytilus$Species) &
  !grepl("Mytilus galloprovincialis",mytilus$Species)&
  !grepl("Mytilus edulis galloprovincialis",mytilus$Species)&
  grepl("Presence", mytilus$PA))
mytilus.duplicates = duplicated(mytilus.valid[, c("Lat","Lon")]) 
mytilus.deduplicated <- subset(cbind(mytilus.valid,mytilus.duplicates), mytilus.duplicates==FALSE)
mytilus.cleaned=mytilus.deduplicated[c("Lon","Lat","PA","Source")]
summary(mytilus.cleaned)
```

Wir benutzen den Dataframe jetzt als spatial data und reichern es mit
Information zu Koordinaten und Referenzsystem aus dem `sp`-Paket an:

```{r}
#myt <- data.frame(mytilus.cleaned$Lon, mytilus.cleaned$Lat, mytilus.cleaned$PA)
library(sp)
coordinates(mytilus.cleaned) <- ~Lon + Lat
proj4string(mytilus.cleaned)<-CRS("+init=epsg:4326")
plot(mytilus.cleaned,cex=0.1)
```

# Korngr√∂√üe (Teil 1)

Die Sedimentdaten sind in zwei Versionen vorhanden, einmal in der Datei `
Predictor.rda` und in einer weiteren Datei `interpolated_d50_NorthSea_1nm.txt`. Hier der Versuch mit der ersten (sp√§ter besser die zweite nehmen, s.u.).  Die Rohdaten sind Mittlere Korngr√∂√üe ("median grain size", msg), und werden in der Krumbein-Phi-Skala dargestellt, d.h. den negativen bin√§ren Logarithmus der auf 1 mm normierten Korngr√∂√üe. 

```{r}
load("Predictor.rda")
library(RColorBrewer)
library(sp)
spplot(Predictor,"mgs",formula=-log2(mgs/1000)~s1+s2,
      col.regions = brewer.pal(11, "Spectral"),
      at=c(-5,-4,-3,-2,-1,0,1,2,3,4,5),
      pretty=TRUE
      )
library(grid)
grid.text("-log2(mgs/1mm)",x=unit(1,"npc"),y=unit(0.50,"npc"),rot=-90)

Predictor$phi <- -log2(Predictor$mgs/1000)
```

Die entscheinden Schritte, um die Umweltdaten mit den Muscheldaten zusammenzubringen, ben√∂tigen das Paket `crecs` von `github`.  Dieses muss mithilfe der `devtools` installiert werden.

```{r}
library(devtools)
#devtools::install_github("janhoo/crecs")
library(crecs)
```
Aus diesem Paket kann der Befehl `get.environ` zu gegebenen Punktdaten (`points`) einen Vektor mit Daten aus der Umgebung (`env`) erzeugen. Die Daten werden auf den Bereich der Korngr√∂√üe zugeschnitten und nur die Spalten PA, mgs und depth werden behalten

```{r}
myt.env<-get.environ(points=mytilus.cleaned,env=stack(Predictor))
#clip the points to SNS
myt.env2<-myt.env[!is.na(myt.env$phi),]
myt.env2 <- myt.env2[,c("PA","depth","mgs","phi")]
summary(myt.env2)
```

Man kann nun mit spplot Korngr√∂√üe und Vorkommen von Mytilus gegen√ºberstellen.
```{r}
PA2_plot <- spplot(myt.env2,"PA",cex=0.1,col.regions=c("red","grey"))
val_plot <- spplot(myt.env2,"phi",cex=0.1)
library(gridExtra)
grid.arrange(val_plot,PA2_plot,ncol=2)
```

Bisher haben wir nur Presence-Daten f√ºr Mytilus. Die Punkte, an denen Mytilus nicht vorkommt, m√ºssen erst noch zuf√§llig generiert werden. Die Funktion randomPoints ist genau f√ºr solche F√§lle gedacht, sie generiert pseudo-absence Daten. Die Anzahl der generierten Punkte soll denen der Presence-Punkte entsprechen. Es sind 1259 Punkte.

```{r}
set.seed(1)
library(dismo)
random.absence.forPredictor <- randomPoints(Predictor,n=1259,mytilus.cleaned)
  #Umwandlung in einen Dataframe und Zuweisung der Koordinaten und eines 
    #Koordinaten-Refererenz Systems --> class=SpatialPoints
random.absence.forPredictor <- as.data.frame(random.absence.forPredictor)
coordinates(random.absence.forPredictor) <- ~ x+y
proj4string(random.absence.forPredictor) <- CRS("+init=epsg:4326")
  #Zusammenbringen der Absence-Punkte mit dem Korngr√∂√üen-Datensatz
myt.absence <- get.environ(random.absence.forPredictor,stack(Predictor))

#Kombinieren von Presence und Absence Punkten und schreiben als 1 f√ºr presence und 2 f√ºr absence
myt.env2$PA2 <- 1
myt.absence$PA2 <- 0
library(maptools)
sedPA.bind <- spRbind(myt.env2[,2:ncol(myt.env2)],myt.absence[,c("depth","mgs","PA2","phi")])
spplot(sedPA.bind,"PA2",cex=0.1,col.regions=c("black","red"))
```

Nun kann das Random Forest Modell angewendet werden. Dazu gibt es ein extra Paket 'randomForest', das zuerst geladen werden muss.

```{r}
sedPA.bind.df <- data.frame(sedPA.bind)
library(randomForest)
rf.p <- randomForest(PA2~phi,data=sedPA.bind.df,ntree=500)
sedPA.bind$Prediction <- rf.p$predicted
library(dismo)
Predictor$prediction1 <- predict(rf.p,Predictor)
spplot(Predictor,"prediction1")
```
Wie ver√§ndert sich das Bild, wenn wir als zweiten Pr√§diktor die Tiefe mit in das Random Forest Modell hinein nehmen?
```{r}
rf.p.withdepth <- randomForest(PA2~phi+depth,data=sedPA.bind.df,ntree=500)
sedPA.bind$PredictionWithDepth <- rf.p.withdepth$predicted
library(dismo)
Predictor$predictionWithDepth <- predict(rf.p.withdepth,Predictor)
spplot(Predictor,"predictionWithDepth")
```

# Korngr√∂√üe (Teil 2)

Die zweiten Sedimentdaten aus `interpolated_d50_NorthSea_1nm.txt` liegen schon als phi-Werte vor.  Diese k√∂nnen ordentlich referenziert werden, denn sie stammen  aus dem [NOAH Habitatatlas](www.noah-project.de).

```{r}
sed <- read.table("interpolated_d50_NorthSea_1nm.txt",header=T,dec=".")
sed <- sed[,1:3]
summary(sed)
sed2 <- sed
coordinates(sed2) <- ~lon + lat
proj4string(sed2)<-CRS("+init=epsg:4326")
spplot(sed2,"val", cex=0.1)
```

Die Daten sind klassifizierte Punkdaten, die in ein kontinuierliches Raster umgewandelt werden sollen. Die angegebene Wert f√ºr tolerance ist der von R vorgeschlagene Wert. Die Angabe des Wertes ist n√∂tig, da die Daten nicht komplett gegridded sind. 


```{r}
sed.pixel=SpatialPixelsDataFrame(sed2,data=sed,tolerance=0.000100658)
spplot(sed.pixel,"val", cex=0.1)
```

Die Mytilus- und die Korngr√∂√üen-Daten werden nun zusammengef√ºhrt und auf den gemeinsamen Bereich zugeschnitten. Damit reduziert sich die Anzahl der Punkte auf 1396.

```{r}
library(crecs)
myt.env<-get.environ(points=mytilus.cleaned,env=stack(sed.pixel))
myt.env <- myt.env[!is.na(myt.env$val),]
summary(myt.env)
```

Es sollen nun 1396 Hintergrundwerte, an denen die Miesmuschel nicht vorkommt, zuf√§llig generiert werden (random-absence). Dies geschieht mit der Funktion randomPoints, die eine Matrix mit x und y Werten erzeugt. Als letztes Argument sind hier die Presence-Punkte angegeben. Dann werden die Zufallswerte nicht in diesen Zellen generiert.

```{r}
set.seed(1)
library(dismo)
random.absence <- randomPoints(sed.pixel,n=1396,mytilus.cleaned)
```

Die Matrix soll in einen SpatialPoints Datensatz umgewandelt werden und bekommt damit einen r√§umlichen Bezug. Anschlie√üend werden die Absence-Punktdaten mit den Korngr√∂√üen-Daten vereint.

```{r}
random.absence <- as.data.frame(random.absence)
coordinates(random.absence) <- ~ x+y
proj4string(random.absence) <- CRS("+init=epsg:4326")

sed.absence <- get.environ(random.absence,stack(sed.pixel))
```

Die Presence-Punktdaten und die generierten Absence-Punktdaten werden jetzt mit einander verbunden. Es wird eine neue Spalte PA2 angelegt, in der das Vorkommen von Mytilus als 1 und die Abwesenheit von Mytilus als 0 definiert wird.

```{r}
myt.env$PA2 <- 1
sed.absence$PA2 <- 0
library(maptools)
mgsPA.bind <- spRbind(myt.env[,3:ncol(myt.env)],sed.absence)
spplot(mgsPA.bind,"PA2",cex=0.01,col.regions=c("black","red"))
```
Mithilfe des Random Forest Modells sollen Vorhersagen √ºber die Wahrscheinlichkeit gemacht werden, mit der die Miesmuschel bei gegebener mittlerer Korngr√∂√üe vorkommt. Die mittlere Korngr√∂√üe ist somit der Pr√§diktor im Modell, das Vorkommen der Miesmuschel die Response-Variable.

```{r}
mgsPA.bind.df <- data.frame(mgsPA.bind)
library(randomForest)
rf <- randomForest(PA2~val,data=mgsPA.bind.df,ntree=500)
mgsPA.bind$Prediction <- rf$predicted
library(dismo)
sed.pixel$prediction <- predict(rf,sed.pixel)
spplot(sed.pixel,"prediction")
```

Wie ver‰ndert sich das Bild, wenn man als zweiten Pr‰diktor die Tiefe mit einbezieht? Wir verwenden den Etopo1 Datensatz, der https://maps.ngdc.noaa.gov/viewers/wcs-client/ abbrufbar ist. 
Die Daten werden eingelesen und durch Zuweisung des Referenz-Koordinaten-Systems und der Koordinaten in einen SpatialPointsDataFrame umgewandelt.
```{r}
  #Einlesen der Tiefedaten und Umwandlung in SpatialPointsDataFrame
depth.etopo.df <- read.csv("etopo1_bedrock.xyz",sep="",header=FALSE)
depth.etopo <- depth.etopo.df 
coordinates(depth.etopo) <- ~V1 + V2
proj4string(depth.etopo)<-CRS("+init=epsg:4326")
```

Der Datensatz l‰sst sich anschlieﬂend ohne Weiteres in einen SpatialPixelsDataFrame ¸berf¸hren
```{r}
  #Umwandlung der Tiefendaten in SpatialPixelsDataFrame
depth.pixel <- SpatialPixelsDataFrame(depth.etopo,depth.etopo.df)
spplot(depth.pixel,"V3")
```
Mit der 'get.environ' Funktion lassen sich dann die Werte jener Punkte extrahieren f¸r die auch Grainsize und PA-Werte vorliegen.
```{r}
mgsDepthPA <- get.environ(mgsPA.bind,stack(depth.pixel))
mgsDepthPA <- mgsDepthPA[!is.na(mgsDepthPA$V3),]

spplot(mgsDepthPA,"V3",cex=0.1)
```


Nun kann man das Random Forest Modell erneut anwenden mit Grainsize und Tiefe als Pr‰diktoren.
```{r}
rf.withDepth <- randomForest(PA2~ val+V3,mgsDepthPA)
```

Um jedoch die Vorhersagewerte als SpatialPixelsDataFrame zu erhalten und abbilden zu kˆnnen, m¸ssen zur Anwendung der Funktion 'predict' Korngrˆﬂe und Tiefe gemeinsam in einem SpatialPixelsDataFrame vorliegen und als zweites Argument der Funktion 'predict' angegeben werden. Das Kombinieren stellt sich allerdings auch wegen unterschiedlicher cellsize als nicht so einfach heraus.
```{r}
#mgs_pixel$prediction <- predict(rf.withDepth,depth.pixel)
```



# Vergleich der Ergebnisse der beiden Korngr√∂√üen-Datens√§tze

Um die Ergebnisse der beiden Korngr√∂√üen-Datens√§tze besser vergleichen zu k√∂nnen, werden sie auf den gemeinsamen Kartenausschnitt zugeschnitten. Dazu wird die Funktion 'intersect' aus dem Paket 'raster' verwendet.

```{r}
library(raster)
intersect.part2 <- intersect(sed.pixel,Predictor)
grainsize.part2 <- spplot(intersect.part2,"prediction")
intersect.part1 <- intersect(Predictor,sed.pixel)
grainsize.part1 <- spplot(intersect.part1,"prediction1")
grainsize.part1
grainsize.part2
```
